{"version":3,"file":"index-dokJR7Uh.js","sources":["../../node_modules/@sankhyalabs/core/dist/utils/KeyboardManager/constants/meta-keys.js","../../node_modules/@sankhyalabs/core/dist/utils/KeyboardManager/index.js"],"sourcesContent":["export const META_KEYS = [\n    \"meta\",\n    \"shift\",\n    \"alt\",\n    \"ctrl\"\n];\n//# sourceMappingURL=meta-keys.js.map","import { JSUtils } from \"../JSUtils.js\";\nimport { StringUtils } from \"../StringUtils.js\";\nimport { META_KEYS } from \"./constants/meta-keys.js\";\nimport { keyCodeEventValues } from \"./keyCodes/index.js\";\n/**\n * `KeyboardManager` é reponsável por gerenciar eventos de teclado.\n */\nexport class KeyboardManager {\n    /**\n     * Construtor para a classe Keyboard.\n     *\n     * @param {IKeyboardOptions} options - opções para o gerenciamento de eventos de teclado.\n     */\n    constructor(options) {\n        this._shadowRoots = [];\n        this._mappedElements = {};\n        this._options = Object.assign({ type: 'keydown', propagate: false, element: document.body, debounceTime: 0, enableShadowDom: false }, options);\n        if (this._options.enableShadowDom) {\n            this._shadowRoots = this.findAllNestedShadowRoots(this._options.element);\n        }\n    }\n    findAllNestedShadowRoots(element, results = []) {\n        if (!element) {\n            return results;\n        }\n        const shadowRoot = element === null || element === void 0 ? void 0 : element.shadowRoot;\n        if (shadowRoot) {\n            results.push(shadowRoot);\n            shadowRoot.querySelectorAll(\"*\").forEach((child) => {\n                this.findAllNestedShadowRoots(child, results);\n            });\n        }\n        element.childNodes.forEach((child) => {\n            this.findAllNestedShadowRoots(child, results);\n        });\n        return results;\n    }\n    addEventListenerToNestedShadowRoots(event, callback) {\n        this._shadowRoots.forEach((shadowRoot) => {\n            shadowRoot.addEventListener(event, callback);\n        });\n    }\n    removeEventListenerToNestedShadowRoots(event, callback) {\n        this._shadowRoots.forEach((shadowRoot) => {\n            shadowRoot.removeEventListener(event, callback);\n        });\n    }\n    /**\n     * Associa um evento de teclado com uma função\n     *\n     * @param {string} keyMap - Chave de mapeamento de teclado.\n     * @param {VoidFunction} callback - Função a ser executada quando o evento de teclado for disparado.\n     * @param {IKeyboardOptions} [options] - Configurações dos eventos de teclado.\n     * @return {KeyboardManager} O objeto `KeyboardManager`\n     */\n    bind(keyMap, callback, options) {\n        var _a;\n        if ((_a = this._mappedElements) === null || _a === void 0 ? void 0 : _a[keyMap]) {\n            throw new Error(\"Event already exists.\");\n        }\n        const bindOptions = Object.assign(Object.assign({}, this._options), options);\n        const debounceFunction = JSUtils.debounceLeading(this.handleListenerEvent, bindOptions.debounceTime, this)\n            .bind(this, keyMap, callback, bindOptions.propagate);\n        this._mappedElements = Object.assign(Object.assign({}, this._mappedElements), { [keyMap]: {\n                callback: debounceFunction,\n                options: bindOptions\n            } });\n        bindOptions.element.addEventListener(bindOptions.type, debounceFunction);\n        if (bindOptions.enableShadowDom) {\n            this.addEventListenerToNestedShadowRoots(bindOptions.type, debounceFunction);\n        }\n        return this;\n    }\n    /**\n     * Remove todos os eventos de teclado ou de uma lista informada\n     *\n     */\n    unbindAllShortcutKeys(listShortcutKeys) {\n        const mappedKeys = [...Object.keys(listShortcutKeys || this._mappedElements)];\n        mappedKeys === null || mappedKeys === void 0 ? void 0 : mappedKeys.forEach(keyMap => this.unbind(keyMap));\n    }\n    /**\n     * Remove um evento de teclado\n     *\n     * @param {string} keyMap - Chave de mapeamento de teclado.\n     * @return {KeyboardManager} - O objeto `KeyboardManager`\n     */\n    unbind(keyMap) {\n        var _a;\n        const unbindElement = (_a = this._mappedElements) === null || _a === void 0 ? void 0 : _a[keyMap];\n        if (!unbindElement) {\n            throw new Error(\"KeyMap not exists.\");\n        }\n        delete this._mappedElements[keyMap];\n        const { callback, options: { element, type } } = unbindElement;\n        element.removeEventListener(type, callback);\n        if (unbindElement.options.enableShadowDom) {\n            this.removeEventListenerToNestedShadowRoots(type, callback);\n        }\n        return this;\n    }\n    /**\n     * Obtém as chaves mapeadas.\n     *\n     * @return {Array<IGetMappedKeys>} chaves mapeadas com descrições\n     */\n    get mappedKeys() {\n        return Object.entries(this._mappedElements).map(([key, value]) => ({\n            [key]: value.options.description || key\n        }));\n    }\n    /**\n     * Executa uma função quando um evento de teclado for disparado\n     *\n     * @param {string} keyMap - Chave de mapeamento de teclado\n     * @param {VoidFunction} callback - Função a ser executada\n     * @param {boolean} propagate - Se o evento de teclado deve ser propagado\n     * @param {KeyboardEvent} event - O evento de teclado\n     */\n    handleListenerEvent(keyMap, callback, propagate, event) {\n        const { isKeyApplied, modifiedList } = this.keyAppliedWithModifiers(keyMap, event.keyCode);\n        if (isKeyApplied && this.checkModifiersIsApplied(event, modifiedList)) {\n            this.verifyAndStopPropagation(event, propagate);\n            (callback || (() => { }))();\n        }\n    }\n    /**\n     * Verifica se um evento de teclado foi disparado\n     *\n     * @param {string} keyMap - Chave de mapeamento de teclado\n     * @param {number} pressedKeyCode - Código do evento de teclado pressionado\n     * @return {IKeyAppliedResponse} Retorna se o evento de teclado foi disparado e as teclas modificadoras aplicadas ao evento\n     */\n    keyAppliedWithModifiers(keyMap, pressedKeyCode) {\n        const keys = keyMap.split(\"+\");\n        let isKeyApplied = false;\n        const modifiedList = [];\n        for (let key of keys) {\n            key = key.trim();\n            if (META_KEYS.includes(key.toLowerCase())) {\n                modifiedList.push(key);\n                continue;\n            }\n            const pressedKey = keyCodeEventValues.reduce((acc, { key: checkKey, keyCode }) => {\n                if (checkKey == key || checkKey == StringUtils.getOppositeCase(key)) {\n                    acc.push(keyCode);\n                }\n                return acc;\n            }, []);\n            if (pressedKey.includes(pressedKeyCode)) {\n                isKeyApplied = true;\n            }\n        }\n        return { isKeyApplied, modifiedList };\n    }\n    /**\n     * Verifica se todas as teclas modificadoras foram aplicadas ao evento\n     *\n     * @param {KeyboardEvent} event - O evento de teclado\n     * @param {Array<string>} modifiedList - As teclas modificadoras\n     * @return {boolean} Retorna se todas as teclas modificadoras foram aplicadas\n     */\n    checkModifiersIsApplied(event, modifiedList) {\n        const eventModifiers = {\n            shift: event.shiftKey,\n            ctrl: event.ctrlKey,\n            alt: event.altKey,\n            meta: event.metaKey,\n        };\n        if (modifiedList.length === 0) {\n            return !(eventModifiers.shift ||\n                eventModifiers.ctrl ||\n                eventModifiers.alt ||\n                eventModifiers.meta);\n        }\n        let hasAllModifiedApplied = true;\n        for (const modifier of modifiedList) {\n            if (!eventModifiers[modifier]) {\n                hasAllModifiedApplied = false;\n                break;\n            }\n        }\n        return hasAllModifiedApplied;\n    }\n    /**\n     * Verifica e impede que o evento de teclado seja propagado\n     *\n     * @param {KeyboardEvent} event - O evento de teclado\n     * @param {boolean} propagate - Se o evento de teclado deve ser propagado\n     * @return {void}\n     */\n    verifyAndStopPropagation(event, propagate) {\n        var _a, _b;\n        if (!propagate) {\n            (_a = event === null || event === void 0 ? void 0 : event.preventDefault) === null || _a === void 0 ? void 0 : _a.call(event);\n            (_b = event === null || event === void 0 ? void 0 : event.stopPropagation) === null || _b === void 0 ? void 0 : _b.call(event);\n        }\n    }\n}\n//# sourceMappingURL=index.js.map"],"names":["META_KEYS","KeyboardManager","options","element","results","shadowRoot","child","event","callback","keyMap","_a","bindOptions","debounceFunction","JSUtils","listShortcutKeys","mappedKeys","unbindElement","type","key","value","propagate","isKeyApplied","modifiedList","pressedKeyCode","keys","keyCodeEventValues","acc","checkKey","keyCode","StringUtils","eventModifiers","hasAllModifiedApplied","modifier","_b"],"mappings":"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","x_google_ignoreList":[0,1]}